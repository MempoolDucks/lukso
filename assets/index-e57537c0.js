if(typeof crypto>"u"||!crypto.subtle)throw new Error("SubtleCrypto not supported!");const s={ES256:{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}},ES384:{name:"ECDSA",namedCurve:"P-384",hash:{name:"SHA-384"}},ES512:{name:"ECDSA",namedCurve:"P-521",hash:{name:"SHA-512"}},HS256:{name:"HMAC",hash:{name:"SHA-256"}},HS384:{name:"HMAC",hash:{name:"SHA-384"}},HS512:{name:"HMAC",hash:{name:"SHA-512"}},RS256:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},RS384:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}},RS512:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}}};function p(r){let t="";for(let e=0;e<r.byteLength;e++)t+=String.fromCharCode(r[e]);return t}function h(r){let t=new Uint8Array(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}function w(r){return btoa(p(new Uint8Array(r)))}function l(r){return h(atob(r)).buffer}function f(r){return h(decodeURI(encodeURIComponent(r)))}function S(r){return w(r).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function b(r){return l(r.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,""))}function u(r){return btoa(r).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function g(r){return l(r.replace(/-+(BEGIN|END).*/g,"").replace(/\s/g,""))}async function E(r,t){return await crypto.subtle.importKey("raw",f(r),t,!0,["verify","sign"])}async function A(r,t){return await crypto.subtle.importKey("jwk",r,t,!0,["verify","sign"])}async function d(r,t){return await crypto.subtle.importKey("spki",g(r),t,!0,["verify"])}async function H(r,t){return await crypto.subtle.importKey("pkcs8",g(r),t,!0,["sign"])}async function y(r,t){if(typeof r=="object")return A(r,t);if(typeof r!="string")throw new Error("Unsupported key type!");return r.includes("PUBLIC")?d(r,t):r.includes("PRIVATE")?H(r,t):E(r,t)}function c(r){try{return JSON.parse(atob(r))}catch{return}}async function C(r,t,e="HS256"){if(typeof e=="string"&&(e={algorithm:e}),e={algorithm:"HS256",header:{typ:"JWT"},...e},!r||typeof r!="object")throw new Error("payload must be an object");if(!t||typeof t!="string"&&typeof t!="object")throw new Error("secret must be a string or a JWK object");if(typeof e.algorithm!="string")throw new Error("options.algorithm must be a string");const n=s[e.algorithm];if(!n)throw new Error("algorithm not found");r.iat||(r.iat=Math.floor(Date.now()/1e3));const o=`${u(JSON.stringify({...e.header,alg:e.algorithm}))}.${u(JSON.stringify(r))}`,a=await y(t,n),i=await crypto.subtle.sign(n,a,f(o));return`${o}.${S(i)}`}async function T(r,t,e={algorithm:"HS256",throwError:!1}){if(typeof e=="string"&&(e={algorithm:e,throwError:!1}),e={algorithm:"HS256",throwError:!1,...e},typeof r!="string")throw new Error("token must be a string");if(typeof t!="string"&&typeof t!="object")throw new Error("secret must be a string or a JWK object");if(typeof e.algorithm!="string")throw new Error("options.algorithm must be a string");const n=r.split(".");if(n.length!==3)throw new Error("token must consist of 3 parts");const o=s[e.algorithm];if(!o)throw new Error("algorithm not found");const{payload:a}=m(r);try{if(!a)throw new Error("PARSE_ERROR");if(a.nbf&&a.nbf>Math.floor(Date.now()/1e3))throw new Error("NOT_YET_VALID");if(a.exp&&a.exp<=Math.floor(Date.now()/1e3))throw new Error("EXPIRED");const i=await y(t,o);return await crypto.subtle.verify(o,i,b(n[2]),f(`${n[0]}.${n[1]}`))}catch(i){if(e.throwError)throw i;return!1}}function m(r){return{header:c(r.split(".")[0].replace(/-/g,"+").replace(/_/g,"/")),payload:c(r.split(".")[1].replace(/-/g,"+").replace(/_/g,"/"))}}const P={sign:C,verify:T,decode:m};export{m as decode,P as default,C as sign,T as verify};
